
void list_dir()
{
	int ino;
	INODE *temp;
	MINODE *mtemp;
	int i,dev; 
	char* cp;
        char buf[BLKSIZE];
	if(pathname[0])
	{
		if(pathname[0]=='/')
			dev=root->dev;
		else
			dev = running->cwd->dev;
		ino=getino(dev,pathname);		
		if(!ino)
			printf("\ndirectory doesn't exist");
			
		mtemp=iget(dev,ino);
		temp=&mtemp->INODE;
		//printf("\nPath name is:%s",mtemp->name);		
	}	
	else
	{
		temp=&(running->cwd->INODE);
		dev= running->cwd->dev;
		printf("\nPath name is:%s",running->cwd->name);		
		
	}
	for(i=0;i<12;i++)
	{	
		iblock=temp->i_block[i];
		if(!iblock)
		{
			return;
		}
		else
		{        
			get_block(dev,iblock,buf);	
			dp = (DIR *)buf;
			cp = (char *)buf;
			
//			put_block(dev, iblock, buf);
			while(dp->rec_len&&*cp<BLKSIZE+buf&&*cp!=NULL)	
			{
				printf("\n%d\t%d\t%s",temp->i_mode,dp->inode,dp->name);
				cp+=dp->rec_len; 
				dp =(DIR*)cp;
			}	
		}
	}
}

int check_list(char *parent,char* child)
{
	int ino;
	INODE *temp;
	MINODE *mtemp;
	int i,dev,flag=1; 
	char* cp;
        char buf[BLKSIZE];
	if(parent[0])
	{
		if(parent[0]=='/')
			dev=root->dev;		
		else
			dev = running->cwd->dev;
		ino=getino(dev,parent);		
		if(!ino)
			printf("\ndirectory doesn't exist");	
		mtemp=iget(dev,ino);
		temp=&mtemp->INODE;
	}	
	
	for(i=0;i<12;i++)
	{	
		iblock=temp->i_block[i];
		if(!iblock)
		{
			return 0;
		}
		else
		{        
			get_block(dev,iblock,buf);	
			dp = (DIR *)buf;
			cp = (char *)buf;
			//put_block(dev, iblock, buf);
			while(dp->rec_len&&(cp<BLKSIZE+buf))//&&(*cp!=NULL))	
			{
				if(strstr(dp->name,child))
					flag=0;			
				cp+=dp->rec_len; 
				dp =(DIR*)cp;
			}	
		}
	}

return 0;
}


void make_dir()
{
	int ino;
	INODE *temp;
	MINODE *mtemp;
	time_t t;
	int i=1,dev; 
	char* cp,*parent,*child;
        char buf[BLKSIZE],tem[256];
	strcpy(tem,pathname);

	parent=dirname(pathname);
	child=basename(tem);	
	printf("\nparent:%s\nchild:%s",parent,child);
	
	if(pathname[0]=='/')
	{
		dev=root->dev;
		//parent.substr(1,strlen(parent));	
	}
	else
		dev=running->cwd->dev;
		

	ino=getino(dev,parent);

	//i=strcmp(parent,".");
	/*if(ino!=root->ino)
		ino=running->cwd->ino;	
*/
	mtemp=iget(dev,ino);
	temp=&mtemp->INODE;
	/*i=check_list(parent,child);
	if(i)
		printf("\ncan create");		
	else 
		printf("\ncant create");*/		
	if((temp->i_mode&DIR_MODE==DIR_MODE)&&i)
	{
	mymkdir(mtemp,child,dev);
	printf("\nmkdir happening");	

	temp->i_links_count++;
	temp->i_atime=ctime(&t);
	}
	mtemp->dirty=1;
	iput(mtemp);	
}



int mymkdir(MINODE *mtemp, char *name,int dev)
{
int ino,bno,i;
MINODE *temp;
INODE *itemp;

char buf[BLKSIZE];
	
	ino = ialloc(dev);    
        bno = balloc(dev);
	if(!ino)
		printf("ino not allocated");
	
	if(!bno)
		printf("bno not allocated");	
	//printf("\nbno after alloc:%d",bno);

	temp = iget(dev, ino);
	itemp=&temp->INODE;

	itemp->i_mode=DIR_MODE;
	itemp->i_uid  = running->uid;	// Owner uid 
  	itemp->i_gid  = running->gid;	// Group Id
  	itemp->i_size = BLKSIZE;		// Size in bytes 
  	itemp->i_links_count = 2;	        // Links count=2 because of . and ..
  	itemp->i_atime =time(0L);
	itemp->i_ctime = time(0L);
	itemp->i_mtime = time(0L);  // set to current time
  	itemp->i_blocks = 2;                	// LINUX: Blocks count in 512-byte chunks 
 	itemp->i_block[0] = bno;             // new DIR has one data block   
	 	for(i=1;i<15;i++)
		itemp->i_block[i] =0; 	
	
  	temp->dirty = 1;               // mark minode dirty
	
	iput(temp);
	
	DIR *dp=(DIR*)buf;
	dp->inode=ino;
	dp->rec_len=12;	
	dp->name_len=1;
	dp->file_type=0;
	strcpy(dp->name,".");
	dp=(DIR*)((int)dp+dp->rec_len);
	dp->inode=mtemp->ino;
	dp->rec_len=1012;
	dp->name_len=2;
	dp->file_type=0;
	strcpy(dp->name,"..");

	put_block(dev,bno,buf);
	
        enter_name(mtemp, ino, name);

return 0;
}

int enter_name(MINODE *pip, int myino, char *myname)
{	
	char buf[BLKSIZE],buf2[BLKSIZE];
	INODE *temp;
	int rem,i=0,bno,bno2,dev,needlen,len,j;
	dev=pip->dev;	
	len=strlen(myname);
	needlen=4*((8 +len+ 3)/4);
		
	//MINODE *t=iget(dev,myino);
	temp=&pip->INODE;

	while(temp->i_block[i]!=0&&i<13)
	{	
		i++;
	}

	bno=temp->i_block[i-1];
	printf("\nbno:%d",bno);
	printf("\ni:%d",i);
	
	get_block(dev,bno,buf);	

	DIR *dp = (DIR *)buf;
	//printf("\ninode:%d",dp->inode);
	
	if(dp->inode==0)
	{
		dp->inode=myino;				
		dp->rec_len=1024;
		dp->name_len=strlen(myname);
		strcpy(dp->name,myname);		
		put_block(dev,bno,buf);		
	}	
	else
	{
		while ((dp+dp->rec_len) <buf + BLKSIZE)
		{
			dp = (DIR *)(dp+dp->rec_len);
		} 
		rem=dp->rec_len-(4*((8 + dp->name_len + 3)/4));
		//printf("\nmy mkdir8");		
		if(rem>=needlen)
		{
			//printf("\nmy mkdir813");
			dp->rec_len=4*((8 + dp->name_len + 3)/4);
			dp=(DIR*)(dp+dp->rec_len);
			dp->inode=myino;				
			dp->rec_len=rem;
			dp->name_len=strlen(myname);
			strcpy(dp->name,myname);		
			put_block(dev,bno,buf);			
		}
		else				
		{
		//	printf("\nmy mkdir8w34");
			bno2=balloc(dev);						
			get_block(dev,bno2,buf2);
			temp->i_block[i]=bno2;
			dp=(DIR*)buf2;				
			dp->inode=myino;				
			dp->rec_len=1024;
			dp->name_len=strlen(myname);
			strcpy(dp->name,myname);		
			put_block(dev,bno2,buf2);
			temp->i_size+=1024;
			pip->dirty=1;
			iput(pip);		
		}
	}
printf("\nentername");	
}

void change_dir()
{
	int ino;
	INODE *temp;
	MINODE *mtemp;
	int i,dev; char* cp;
        char buf[BLKSIZE];
	if(pathname[0])
	{
		if(pathname[0]=='/')
			dev=root->dev;		
		else
			dev = running->cwd->dev;
		ino=getino(dev,pathname);		
		if(!ino)
			printf("\ndirectory doesn't exist");	
		mtemp=iget(dev,ino);
		temp=&mtemp->INODE;	
		running->cwd=mtemp;
	}	
	else
	{
		temp=&(running->cwd->INODE);
		dev= running->cwd->dev;
	}

	if(!strcmp(pathname,".."))
		running->cwd->refCount--;
	else
		running->cwd->refCount++;
	iput(mtemp);
}


void my_rpwd(MINODE *mip) {
	
	if(mip == root) {
		return; 
	} 
	else {
		MINODE *temp;
		//INODE *itemp;		
		temp=iget(mip->dev,mip->ino);
		//itemp=&temp->INODE;	
		my_rpwd(temp);
		
		printf("/%s", temp->name);

		return;
	}

}




void pwd() {
	
	if(running->cwd == root) {
		printf("/");
	} else {
		my_rpwd(running->cwd);
	}
	printf("\n");
}
